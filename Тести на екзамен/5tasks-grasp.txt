::Тестове завдання "SOLID: переваги принципу SOLID”::
Які переваги може дати використання принципів SOLID?:
{
~%20%Зведення змін в коді до простого додаванню / видаленню складових частин - модулів.
~%20%Код легко використовувати повторно.
~%20%Легко розуміти, яка частина коду за що відповідає.
~%20%Можливість відкласти конкретні технічні рішення, створюючи при цьому основну логіку роботи.
~%20%Можливість поділу праці програмістів, паралельної розробки.
}

::Тестове завдання "Загальне питання: абревіатури принципів об'єктно-орієнтованого дизайну”::
Які абревіатури принципів об'єктно-орієнтованого дизайну ви знаєте?:
{
~%25%KISS
~WASH
~CLEAN
~%25%SOLID 
~%25%DRY
~%25%YAGNI
}

::Тестове завдання "GRASP: визначення принципу Polymorphism”::
Виберіть принцип Polymorphism:
{
~Описує основні принципи призначення обов'язків класів і об'єктів.
~Суть відповідальності такого об'єкта в тому, що він створює інші об'єкти.
~Відповідає за обробку вхідних системних подій, делегуючи обов'язки по їх обробці компетентним класах.
~Якщо об'єкти в додатку сильно пов'язані, то будь-який їх зміна призводить до змін у всіх пов'язаних об'єктах. 
~Цей принцип тісно співвідноситься з слабкою пов'язаністю, і вони йдуть в парі, коли одне завжди призводить до іншого, це як міра того, що ми не порушуємо single resposibility principle.
~Це клас, який не відбиває ніякого реального об'єкта предметної області, але спеціально придуманий для посилення зв'язності, ослаблення пов'язаності або збільшення ступеня повторного використання.
~Шаблон перенаправлення реалізує низьку зв'язність між класами, шляхом призначення обов'язків по їх взаємодії додатковому об'єкту - посереднику.
~Захищає елементи від зміни інших елементів (об'єктів або підсистем) за допомогою винесення взаємодії в фіксований інтерфейс.
=Дозволяє обробляти альтернативні варіанти поведінки на основі типу та замінювати підключаються компоненти системи.
}

::Тестове завдання "GRASP: визначення принципу Protected Variations”::
Виберіть принцип Protected Variations:
{
~Описує основні принципи призначення обов'язків класів і об'єктів.
~Суть відповідальності такого об'єкта в тому, що він створює інші об'єкти.
~Відповідає за обробку вхідних системних подій, делегуючи обов'язки по їх обробці компетентним класах.
~Якщо об'єкти в додатку сильно пов'язані, то будь-який їх зміна призводить до змін у всіх пов'язаних об'єктах. 
~Цей принцип тісно співвідноситься з слабкою пов'язаністю, і вони йдуть в парі, коли одне завжди призводить до іншого, це як міра того, що ми не порушуємо single resposibility principle.
~Це клас, який не відбиває ніякого реального об'єкта предметної області, але спеціально придуманий для посилення зв'язності, ослаблення пов'язаності або збільшення ступеня повторного використання.
~Шаблон перенаправлення реалізує низьку зв'язність між класами, шляхом призначення обов'язків по їх взаємодії додатковому об'єкту - посереднику.
=Захищає елементи від зміни інших елементів (об'єктів або підсистем) за допомогою винесення взаємодії в фіксований інтерфейс.
~Дозволяє обробляти альтернативні варіанти поведінки на основі типу та замінювати підключаються компоненти системи.
}

::Тестове завдання "GRASP: визначення принципу Indirection”::
Виберіть принцип Indirection:
{
~Описує основні принципи призначення обов'язків класів і об'єктів.
~Суть відповідальності такого об'єкта в тому, що він створює інші об'єкти.
~Відповідає за обробку вхідних системних подій, делегуючи обов'язки по їх обробці компетентним класах.
~Якщо об'єкти в додатку сильно пов'язані, то будь-який їх зміна призводить до змін у всіх пов'язаних об'єктах. 
~Цей принцип тісно співвідноситься з слабкою пов'язаністю, і вони йдуть в парі, коли одне завжди призводить до іншого, це як міра того, що ми не порушуємо single resposibility principle.
~Це клас, який не відбиває ніякого реального об'єкта предметної області, але спеціально придуманий для посилення зв'язності, ослаблення пов'язаності або збільшення ступеня повторного використання.
=Шаблон перенаправлення реалізує низьку зв'язність між класами, шляхом призначення обов'язків по їх взаємодії додатковому об'єкту - посереднику.
~Захищає елементи від зміни інших елементів (об'єктів або підсистем) за допомогою винесення взаємодії в фіксований інтерфейс.
~Дозволяє обробляти альтернативні варіанти поведінки на основі типу та замінювати підключаються компоненти системи.
}

::Тестове завдання "GRASP: визначення принципу Pure Fabrication”::
Виберіть принцип Pure Fabrication:
{
~Описує основні принципи призначення обов'язків класів і об'єктів.
~Суть відповідальності такого об'єкта в тому, що він створює інші об'єкти.
~Відповідає за обробку вхідних системних подій, делегуючи обов'язки по їх обробці компетентним класах.
~Якщо об'єкти в додатку сильно пов'язані, то будь-який їх зміна призводить до змін у всіх пов'язаних об'єктах. 
~Цей принцип тісно співвідноситься з слабкою пов'язаністю, і вони йдуть в парі, коли одне завжди призводить до іншого, це як міра того, що ми не порушуємо single resposibility principle.
=Це клас, який не відбиває ніякого реального об'єкта предметної області, але спеціально придуманий для посилення зв'язності, ослаблення пов'язаності або збільшення ступеня повторного використання.
~Шаблон перенаправлення реалізує низьку зв'язність між класами, шляхом призначення обов'язків по їх взаємодії додатковому об'єкту - посереднику.
~Захищає елементи від зміни інших елементів (об'єктів або підсистем) за допомогою винесення взаємодії в фіксований інтерфейс.
~Дозволяє обробляти альтернативні варіанти поведінки на основі типу та замінювати підключаються компоненти системи.
}

::Тестове завдання "GRASP: визначення принципу High Cohesion”::
Виберіть принцип High Cohesion:
{
~Описує основні принципи призначення обов'язків класів і об'єктів.
~Суть відповідальності такого об'єкта в тому, що він створює інші об'єкти.
~Відповідає за обробку вхідних системних подій, делегуючи обов'язки по їх обробці компетентним класах.
~Якщо об'єкти в додатку сильно пов'язані, то будь-який їх зміна призводить до змін у всіх пов'язаних об'єктах. 
=Цей принцип тісно співвідноситься з слабкою пов'язаністю, і вони йдуть в парі, коли одне завжди призводить до іншого, це як міра того, що ми не порушуємо single resposibility principle.
~Це клас, який не відбиває ніякого реального об'єкта предметної області, але спеціально придуманий для посилення зв'язності, ослаблення пов'язаності або збільшення ступеня повторного використання.
~Шаблон перенаправлення реалізує низьку зв'язність між класами, шляхом призначення обов'язків по їх взаємодії додатковому об'єкту - посереднику.
~Захищає елементи від зміни інших елементів (об'єктів або підсистем) за допомогою винесення взаємодії в фіксований інтерфейс.
~Дозволяє обробляти альтернативні варіанти поведінки на основі типу та замінювати підключаються компоненти системи.
}

::Тестове завдання "GRASP: визначення принципу Low Coupling”::
Виберіть принцип Low Coupling:
{
~Описує основні принципи призначення обов'язків класів і об'єктів.
~Суть відповідальності такого об'єкта в тому, що він створює інші об'єкти.
~Відповідає за обробку вхідних системних подій, делегуючи обов'язки по їх обробці компетентним класах.
=Якщо об'єкти в додатку сильно пов'язані, то будь-який їх зміна призводить до змін у всіх пов'язаних об'єктах. 
~Цей принцип тісно співвідноситься з слабкою пов'язаністю, і вони йдуть в парі, коли одне завжди призводить до іншого, це як міра того, що ми не порушуємо single resposibility principle.
~Це клас, який не відбиває ніякого реального об'єкта предметної області, але спеціально придуманий для посилення зв'язності, ослаблення пов'язаності або збільшення ступеня повторного використання.
~Шаблон перенаправлення реалізує низьку зв'язність між класами, шляхом призначення обов'язків по їх взаємодії додатковому об'єкту - посереднику.
~Захищає елементи від зміни інших елементів (об'єктів або підсистем) за допомогою винесення взаємодії в фіксований інтерфейс.
~Дозволяє обробляти альтернативні варіанти поведінки на основі типу та замінювати підключаються компоненти системи.
}

::Тестове завдання "GRASP: визначення принципу Controller”::
Виберіть принцип Controller:
{
~Описує основні принципи призначення обов'язків класів і об'єктів.
~Суть відповідальності такого об'єкта в тому, що він створює інші об'єкти.
=Відповідає за обробку вхідних системних подій, делегуючи обов'язки по їх обробці компетентним класах.
~Якщо об'єкти в додатку сильно пов'язані, то будь-який їх зміна призводить до змін у всіх пов'язаних об'єктах. 
~Цей принцип тісно співвідноситься з слабкою пов'язаністю, і вони йдуть в парі, коли одне завжди призводить до іншого, це як міра того, що ми не порушуємо single resposibility principle.
~Це клас, який не відбиває ніякого реального об'єкта предметної області, але спеціально придуманий для посилення зв'язності, ослаблення пов'язаності або збільшення ступеня повторного використання.
~Шаблон перенаправлення реалізує низьку зв'язність між класами, шляхом призначення обов'язків по їх взаємодії додатковому об'єкту - посереднику.
~Захищає елементи від зміни інших елементів (об'єктів або підсистем) за допомогою винесення взаємодії в фіксований інтерфейс.
~Дозволяє обробляти альтернативні варіанти поведінки на основі типу та замінювати підключаються компоненти системи.
}

::Тестове завдання "GRASP: визначення принципу Creator”::
Виберіть принцип Creator:
{
~Описує основні принципи призначення обов'язків класів і об'єктів.
=Суть відповідальності такого об'єкта в тому, що він створює інші об'єкти.
~Відповідає за обробку вхідних системних подій, делегуючи обов'язки по їх обробці компетентним класах.
~Якщо об'єкти в додатку сильно пов'язані, то будь-який їх зміна призводить до змін у всіх пов'язаних об'єктах. 
~Цей принцип тісно співвідноситься з слабкою пов'язаністю, і вони йдуть в парі, коли одне завжди призводить до іншого, це як міра того, що ми не порушуємо single resposibility principle.
~Це клас, який не відбиває ніякого реального об'єкта предметної області, але спеціально придуманий для посилення зв'язності, ослаблення пов'язаності або збільшення ступеня повторного використання.
~Шаблон перенаправлення реалізує низьку зв'язність між класами, шляхом призначення обов'язків по їх взаємодії додатковому об'єкту - посереднику.
~Захищає елементи від зміни інших елементів (об'єктів або підсистем) за допомогою винесення взаємодії в фіксований інтерфейс.
~Дозволяє обробляти альтернативні варіанти поведінки на основі типу та замінювати підключаються компоненти системи.
}

::Тестове завдання "GRASP: визначення принципу Information Expert”::
Виберіть принцип Information Expert:
{
=Описує основні принципи призначення обов'язків класів і об'єктів.
~Суть відповідальності такого об'єкта в тому, що він створює інші об'єкти.
~Відповідає за обробку вхідних системних подій, делегуючи обов'язки по їх обробці компетентним класах.
~Якщо об'єкти в додатку сильно пов'язані, то будь-який їх зміна призводить до змін у всіх пов'язаних об'єктах. 
~Цей принцип тісно співвідноситься з слабкою пов'язаністю, і вони йдуть в парі, коли одне завжди призводить до іншого, це як міра того, що ми не порушуємо single resposibility principle.
~Це клас, який не відбиває ніякого реального об'єкта предметної області, але спеціально придуманий для посилення зв'язності, ослаблення пов'язаності або збільшення ступеня повторного використання.
~Шаблон перенаправлення реалізує низьку зв'язність між класами, шляхом призначення обов'язків по їх взаємодії додатковому об'єкту - посереднику.
~Захищає елементи від зміни інших елементів (об'єктів або підсистем) за допомогою винесення взаємодії в фіксований інтерфейс.
~Дозволяє обробляти альтернативні варіанти поведінки на основі типу та замінювати підключаються компоненти системи.
}

::Тестове завдання "SOLID: визначення принципу інверсії залежностей”::
Виберіть принцип інверсії залежностей:
{
~Кожен об'єкт має виконувати лише один обов'язок.
~Розширення певного класу/інтерфейсу може здійснюватись через його успадкування.
~Об'єкти в програмі можуть бути заміненими їх нащадками без зміни коду програми.
~Багато спеціалізованих інтерфейсів краще за один універсальний.
=Модулі вищих рівнів не мають залежати від модулів нижчих рівнів.
}

::Тестове завдання "SOLID: визначення принципу розділення інтерфейсу”::
Виберіть принцип розділення інтерфейсу:
{
~Кожен об'єкт має виконувати лише один обов'язок.
~Розширення певного класу/інтерфейсу може здійснюватись через його успадкування.
~Об'єкти в програмі можуть бути заміненими їх нащадками без зміни коду програми.
=Багато спеціалізованих інтерфейсів краще за один універсальний.
~Модулі вищих рівнів не мають залежати від модулів нижчих рівнів.
}

::Тестове завдання "SOLID: визначення принципу підстановки Лісков”::
Виберіть принцип підстановки Лісков:
{
~Кожен об'єкт має виконувати лише один обов'язок.
~Розширення певного класу/інтерфейсу може здійснюватись через його успадкування.
=Об'єкти в програмі можуть бути заміненими їх нащадками без зміни коду програми.
~Багато спеціалізованих інтерфейсів краще за один універсальний.
~Модулі вищих рівнів не мають залежати від модулів нижчих рівнів.
}

::Тестове завдання "SOLID: визначення принципу відкритості/закритості”::
Виберіть принцип відкритості/закритості:
{
~Кожен об'єкт має виконувати лише один обов'язок.
=Розширення певного класу/інтерфейсу може здійснюватись через його успадкування.
~Об'єкти в програмі можуть бути заміненими їх нащадками без зміни коду програми.
~Багато спеціалізованих інтерфейсів краще за один універсальний.
~Модулі вищих рівнів не мають залежати від модулів нижчих рівнів.
}

::Тестове завдання "SOLID: визначення принципу єдиного обов'язку”::
Виберіть принцип єдиного обов'язку:
{
=Кожен об'єкт має виконувати лише один обов'язок.
~Розширення певного класу/інтерфейсу може здійснюватись через його успадкування.
~Об'єкти в програмі можуть бути заміненими їх нащадками без зміни коду програми.
~Багато спеціалізованих інтерфейсів краще за один універсальний.
~Модулі вищих рівнів не мають залежати від модулів нижчих рівнів.
}

::Тестове завдання "YAGNI: небажані наслідки непотрібного коду”::
До яких небажаних наслідків може привести написаний код, який не потрібний прямо зараз за принципом YAGNI::
{
~%25%Витрачається час, який було б витрачено на додавання, тестування і поліпшення необхідного функціонала.
~Це призводить до того, що програмне забезпечення стає простішою.
~%25%Новий функціонал повинен бути налагоджений, документований і підтримуватися.
~Новий функціонал не обмежує те, що може бути зроблено в майбутньому.
}

::Тестове завдання "YANGI: визначення”::
Виберіть принцип YANGI:
{
~Принцип декларує простоту системи в якості основної мети та / або цінності.
=Суть принципу в тому, щоб реалізувати тільки поставлені завдання і відмовитися від надмірного функціоналу.
~Принцип розробки програмного забезпечення, націлений на зниження повторення інформації різного роду, особливо в системах з безліччю шарів абстрагування.
}

::Тестове завдання "DRY: визначення”::
Виберіть принцип DRY:
{
~Принцип декларує простоту системи в якості основної мети та / або цінності.
~Суть принципу в тому, щоб реалізувати тільки поставлені завдання і відмовитися від надмірного функціоналу.
=Принцип розробки програмного забезпечення, націлений на зниження повторення інформації різного роду, особливо в системах з безліччю шарів абстрагування.
}

::Тестове завдання "KISS: визначення”::
Виберіть принцип KISS:
{
=Принцип декларує простоту системи в якості основної мети та / або цінності.
~Суть принципу в тому, щоб реалізувати тільки поставлені завдання і відмовитися від надмірного функціоналу.
~Принцип розробки програмного забезпечення, націлений на зниження повторення інформації різного роду, особливо в системах з безліччю шарів абстрагування.
}

::Тестове завдання "GRASP: визначення”::
Виберіть принципи GRASP:
{
~%10%Information Expert
~%10%Creator
~%10%Controller
~%10%Low Coupling
~Liskov Substitution Principle
~%10%High Cohesion
~%10%Polymorphism
~Dependency Inversion
~%10%Pure Fabrication
~%30%Indirection та Protected Variations 
~Interface Segregation
~Open-Closed
}

::Тестове завдання "SOLID: визначення”::
Виберіть принципи SOLID:
{
~Information Expert
~%20%The Dependency Inversion
~Creator
~%20%Single Responsibility
~%20%Open-Closed 
~High Cohesion
~%20%Interface Segregation
~Polymorphism
~Indirection
~%20%Liskov Substitution
~Protected Variations
}

::Тестове завдання "GRASP Information Expert (Інформаційний експерт) переваги”::
Переваги принципу GRASP Information Expert (Інформаційний експерт):
{
~%50%Підтримує інкапсуляцію, тобто об'єкти використовують свої власні дані для виконання поставлених завдань
~Використання цього патерну не підвищує пов'язаності, оскільки створений клас, як правило, видно тільки для класу - творця. 
~%50%Поведінка системи забезпечується класами, що містять необхідну інформацію. 
~Зручність повторного використання
~Класи з високим ступенем зачеплення прості в підтримці і повторному використанні.
}

::Тестове завдання "GRASP Creator (Творець) переваги”::
Переваги принципу Creator (Творець):
{
~Підтримує інкапсуляцію, тобто об'єкти використовують свої власні дані для виконання поставлених завдань
=Використання цього патерну не підвищує пов'язаності, оскільки створений клас, як правило, видно тільки для класу - творця. 
~Поведінка системи забезпечується класами, що містять необхідну інформацію. 
~Зручність повторного використання
~Підтримується High Cohesion
~Класи з високим ступенем зачеплення прості в підтримці і повторному використанні.
}

::Тестове завдання "GRASP Low Coupling (Слабка зв'язаність)  переваги”::
Переваги принципу Low Coupling (Слабка зв'язаність):
{
~%50%Принципи роботи і функції класів / компонентів можна зрозуміти, не вивчаючи інші об'єкти
~Підтримує інкапсуляцію, тобто об'єкти використовують свої власні дані для виконання поставлених завдань
~%50%Зміна компонентів мало позначається на інших об'єктах 
~Підтримується High Cohesion
~Використання цього патерну не підвищує пов'язаності, оскільки створений клас, як правило, видно тільки для класу - творця. 
~Поведінка системи забезпечується класами, що містять необхідну інформацію. 
~Класи з високим ступенем зачеплення прості в підтримці і повторному використанні.
}

::Тестове завдання " CQRS: визначення”::
Виберіть принципи CQRS:
{
~Single Responsibility
~%25%Command 
~%25%Query 
~Creator
~Controller
~%25%Responsibility 
~%25%Segregation
}

::Тестове завдання "CQRS переваги”::
Переваги принципів CQRS:
{
~%25%Можливість розширювати та оптимізувати кожну з сторін додатку незалежно одна від одної
~Поведінка системи забезпечується класами, що містять необхідну інформацію. 
~%25%Розподіл роботи між окремими командами розробників
~Зручність повторного використання
~%25%Можливість створити інтерактивний, задачо-орієнтований користувацький інтерфейс
~Поведінка системи забезпечується класами, що містять необхідну інформацію. 
~%25%Використання однієї або різних баз даних
}